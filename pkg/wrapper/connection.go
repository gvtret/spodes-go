package wrapper

import (
	"bytes"
	"fmt"
	"net"
	"sync"
	"time"

	"github.com/gvtret/spodes-go/pkg/transport"
)

var _ transport.Transport = (*Connection)(nil)

// Config holds the configuration for a WRAPPER connection.
type Config struct {
	SrcAddr     uint16
	DstAddr     uint16
	ReadTimeout time.Duration
}

// DefaultConfig returns a default configuration.
func DefaultConfig() *Config {
	return &Config{
		SrcAddr:     0x01, // Default Client Address
		DstAddr:     0x11, // Default Server Address
		ReadTimeout: 30 * time.Second,
	}
}

// Connection implements the transport.Transport interface for the WRAPPER protocol.
type Connection struct {
	conn           net.Conn
	config         *Config
	readBuffer     bytes.Buffer
	reassembledPDU chan []byte
	mutex          sync.Mutex
	isConnected    bool
}

// NewConnection creates a new WRAPPER connection.
func NewConnection(conn net.Conn, config *Config) *Connection {
	if config == nil {
		config = DefaultConfig()
	}
	return &Connection{
		conn:           conn,
		config:         config,
		reassembledPDU: make(chan []byte, 10),
		isConnected:    true, // Assume connected if we are given a net.Conn
	}
}

// Connect implements the transport.Transport interface. For WRAPPER over TCP, this is a no-op
// as the connection is assumed to be established when the struct is created.
func (c *Connection) Connect() ([]byte, error) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.isConnected = true
	return nil, nil // No initial message needed for WRAPPER protocol
}

// Disconnect implements the transport.Transport interface. It closes the underlying connection.
func (c *Connection) Disconnect() ([]byte, error) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	if !c.isConnected {
		return nil, nil
	}
	c.isConnected = false
	c.conn.Close()
	return nil, nil // No final message needed for WRAPPER protocol
}

// IsConnected implements the transport.Transport interface.
func (c *Connection) IsConnected() bool {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	return c.isConnected
}

// Send implements the transport.Transport interface. It takes a PDU, wraps it in a WRAPPER frame,
// and returns the encoded frame as a slice of byte slices.
func (c *Connection) Send(pdu []byte) ([][]byte, error) {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	if !c.isConnected {
		return nil, fmt.Errorf("connection is closed")
	}

	frame := &Frame{
		Version: Version,
		SrcAddr: c.config.SrcAddr,
		DstAddr: c.config.DstAddr,
		Length:  uint16(len(pdu)),
		Payload: pdu,
	}

	encoded, err := frame.Encode()
	if err != nil {
		return nil, err
	}

	return [][]byte{encoded}, nil
}

// Receive implements the transport.Transport interface. It processes an incoming byte stream,
// decodes complete frames, and passes the reassembled PDUs to the Read method via a channel.
func (c *Connection) Receive(src []byte) ([][]byte, error) {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	c.readBuffer.Write(src)

	for {
		if c.readBuffer.Len() < 8 {
			// Not enough data for a frame header, wait for more data.
			break
		}

		header := c.readBuffer.Bytes()[:8]
		length := uint16(header[6])<<8 | uint16(header[7])
		frameLength := 8 + int(length)

		if c.readBuffer.Len() < frameLength {
			// Not enough data for the full frame payload, wait for more data.
			break
		}

		// We have a complete frame, so we can process it.
		frameBytes := c.readBuffer.Next(frameLength)
		frame := &Frame{}
		err := frame.Decode(frameBytes)
		if err != nil {
			// Skip malformed frames.
			continue
		}
		if frame.Version != Version {
			// Skip frames with an invalid version.
			continue
		}

		// Send the reassembled PDU to be picked up by the Read() method.
		c.reassembledPDU <- frame.Payload
	}

	// The WRAPPER layer itself does not generate response frames (like ACKs).
	// Any response is a PDU generated by the application layer.
	return nil, nil
}

// Read implements the transport.Transport interface. It blocks until a complete PDU
// has been reassembled by the Receive method or a timeout occurs.
func (c *Connection) Read() ([]byte, error) {
	select {
	case pdu := <-c.reassembledPDU:
		return pdu, nil
	case <-time.After(c.config.ReadTimeout):
		return nil, fmt.Errorf("read timeout")
	}
}
